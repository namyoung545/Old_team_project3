<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì „ê¸°ì•ˆì „ ì ê²€ 3D ëª¨ë¸</title>

    <!-- âœ… Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/MTLLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        let scene, camera, renderer, controls, gui;
        let industrials = []; // âœ… ê³µì¥ ê°ì²´ ë°°ì—´
        let worker, floor;
        let directionalLight, ambientLight, pointLight;

        let settings = {
            speed: 0.1,
            height: 10,
            radius: 42,
            enableAuto: false,
            zoom: 10, // âœ… ì¹´ë©”ë¼ ì¤Œ ê¸°ë³¸ê°’ (FOV)
            factoryCount: 5, // âœ… ê³µì¥ ê°œìˆ˜
            factorySpacing: 10 // âœ… ê³µì¥ ê°„ê²© (ìˆ˜ë¦¬ì›ê³¼ ê³µì¥ ê±°ë¦¬ ì •ë„)
        };
        function init() {
            // âœ… Three.js ê¸°ë³¸ ì„¤ì •
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0); // ë°°ê²½ìƒ‰ (íšŒìƒ‰)

            // âœ… ì¹´ë©”ë¼ ì„¤ì • (ì´ˆê¸° ìœ„ì¹˜)
            camera = new THREE.PerspectiveCamera(settings.zoom, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-20, 7, 45);

            // âœ… ë Œë”ëŸ¬ ìƒì„±
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // âœ… OrbitControls ì¶”ê°€ (ë§ˆìš°ìŠ¤ë¡œ ì¡°ì‘ ê°€ëŠ¥)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;  
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2; 

            
            addLights(); // âœ… ì¡°ëª… ì¶”ê°€
            addFog(); // ì•ˆê°œ ì¶”ê°€
            addFactoryFloor();// âœ… ê³µì¥ ë°”ë‹¥ ì¶”ê°€ (í…ìŠ¤ì²˜ ì ìš©)
            loadFuseBox(); // âœ… í“¨ì¦ˆ ë°°ì „ë°˜(Fuse Box) ë¡œë“œ

            loadModels(); // âœ… 3D ëª¨ë¸ ë¡œë“œ (ê³µì¥ ë° ì‚¬ëŒ)

            createSkyDome(); // âœ… ìŠ¤ì¹´ì´ë” ì¶”ê°€

            createGround();  // âœ… ë°”ë‹¥ ì¶”ê°€

            // âœ… ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
            animate();
        }
        function addLights() {
            ambientLight = new THREE.AmbientLight(0xffffff, 0); // í™˜ê²½ê´‘ ê°•ë„
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0); // ì¡°ëª… ê°•ë„
            directionalLight.position.set(-50, 0, -50); // ì¡°ëª… ìœ„ì¹˜
            scene.add(directionalLight); // ì¡°ëª… ì¶”ê°€

            pointLight = new THREE.PointLight(0xffffff, 2, 100);
            pointLight.position.set(0, 10, 10);
            scene.add(pointLight);
        }

        function loadFuseBox() {
            const mtlLoader = new THREE.MTLLoader();
            const objLoader = new THREE.OBJLoader();

            // âœ… MTL ë° OBJ ê²½ë¡œ ì„¤ì •
            mtlLoader.setPath("/models/industrial/");
            objLoader.setPath("/models/industrial/");

            // âœ… MTL íŒŒì¼ ë¡œë“œ
            mtlLoader.load("fus.mtl", function(materials) {
                materials.preload();  // âœ… ì¬ì§ˆ ì‚¬ì „ ë¡œë“œ
                objLoader.setMaterials(materials);

                // âœ… OBJ íŒŒì¼ ë¡œë“œ
                objLoader.load("fus.obj", function(object) {
                    object.scale.set(0.1, 0.1, 0.1);  // í¬ê¸° ì¶•ì†Œ
                    object.position.set(0, -0.2, 1.8);  // ê³µì¥ ë²½ì— ë°€ì°© ë°°ì¹˜
                    scene.add(object);
                    fuseBox = object;
                    console.log("âœ… í“¨ì¦ˆ ë°°ì „ë°˜ ë¡œë“œ ì™„ë£Œ:", fuseBox);
                }, 
                function(xhr) {  // âœ… ë¡œë”© ì§„í–‰ë¥  í‘œì‹œ
                    console.log((xhr.loaded / xhr.total * 100) + "% ë¡œë“œ ì™„ë£Œ");
                }, 
                function(error) {  // âœ… ë¡œë”© ì‹¤íŒ¨ì‹œ ì˜¤ë¥˜ ì¶œë ¥
                    console.error("âŒ í“¨ì¦ˆ ë°°ì „ë°˜ ë¡œë“œ ì‹¤íŒ¨:", error);
                });
            }, 
            function(xhr) {  // âœ… ë¡œë”© ì§„í–‰ë¥  í‘œì‹œ
                console.log((xhr.loaded / xhr.total * 100) + "% MTL ë¡œë“œ ì™„ë£Œ");
            }, 
            function(error) {  // âœ… ë¡œë”© ì‹¤íŒ¨ì‹œ ì˜¤ë¥˜ ì¶œë ¥
                console.error("âŒ MTL ë¡œë“œ ì‹¤íŒ¨:", error);
            });
        }

        function addFactoryFloor() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(settings.floorTexture, function(texture) {
                texture.wrapS = THREE.RepeatWrapping; // ê°€ë¡œ ë°˜ë³µ
                texture.wrapT = THREE.RepeatWrapping; // ì„¸ë¡œ ë°˜ë³µ
                texture.repeat.set(10, 10); // ë°”ë‹¥ ë°˜ë³µ ê°œìˆ˜ ì„¤ì •

                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    map: texture,
                    roughness: 0.8, 
                    metalness: 0.1 
                });

                const floorGeometry = new THREE.PlaneGeometry(200, 200);
                floor = new THREE.Mesh(floorGeometry, floorMaterial);
                
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -1.5; 

                scene.add(floor);
            });
        }

        function loadModels() {
            const objLoader = new THREE.OBJLoader();
            const textureLoader = new THREE.TextureLoader();

            // ğŸ“Œ ê³µì¥ ëª¨ë¸ 5ê°œ ë¡œë“œ (ë°˜ë³µë¬¸ ì‚¬ìš©)
            objLoader.load("/models/industrial/Industrial.obj", function (object) {
                const texture = textureLoader.load("/models/industrial/textures/IndSet_0001.jpg");
                const normalMap = textureLoader.load("/models/industrial/textures/IndSet_0001_Normal.jpg");

                for (let i = 0; i < settings.factoryCount; i++) {
                    let factory = object.clone();
                    factory.traverse(function (child) {
                        if (child.isMesh) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: texture,
                                normalMap: normalMap,
                                roughness: 0.8,
                                metalness: 0.2
                            });
                        }
                    });

                    factory.scale.set(0.4, 0.4, 0.4);
                    factory.position.set(i * settings.factorySpacing, -1.5, 0); // âœ… ê³µì¥ ê°„ê²© ì„¤ì •
                    industrials.push(factory);
                    scene.add(factory);
                }
            });

            // ğŸ“Œ ì‚¬ëŒ(Worker) ëª¨ë¸ ë¡œë“œ
            objLoader.load("/models/worker/worker.obj", function (object) {
                console.log("âœ… Worker ëª¨ë¸ ë¡œë“œë¨:", object);
                worker = object;
                scene.add(worker);
                object.traverse(function (child) {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
                    }
                });

                object.scale.set(1.5, 1.5, 1.5);
                object.position.set(-5, -1.5, 10); // ìˆ˜ë¦¬ì› ìœ„ì¹˜
                object.rotation.y = Math.PI / 1.0; // âœ… ê³µì¥ ìª½ìœ¼ë¡œ ë°©í–¥ íšŒì „
                worker = object;
                scene.add(object);

                // âœ… ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ìˆ˜ë¦¬ê³µ ì´ë™ â†’ íŒ” ë‹¤ë¦¬ ì›€ì§ì„)
                console.log("Worker ëª¨ë¸ ë¡œë“œ ì™„ë£Œ! ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘...");
                animateWorker();
            });

            // ğŸ“Œ ìˆ˜ë¦¬ê³µ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜ (ì´ë™)
            function animateWorker() {
            if (!worker) {
                console.error("Worker ëª¨ë¸ì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                return;
            }
            let targetX = 0;  // ê³µì¥ ìœ„ì¹˜ (X ì¢Œí‘œ)
            let targetZ = 3;  // ê³µì¥ ì•ìœ¼ë¡œ ì´ë™

            // âœ… GSAPì„ ì‚¬ìš©í•˜ì—¬ ìì—°ìŠ¤ëŸ½ê²Œ ì´ë™
            gsap.to(worker.position, {
                x: targetX,
                z: targetZ,
                duration: 2.5, // ì´ë™ ì†ë„ (ì´ˆ)
                ease: "power1.inOut",
                onComplete: () => {
                    console.log("ìˆ˜ë¦¬ê³µì´ ê³µì¥ì— ë„ì°©!");
                    animateWorkerArms(); // íŒ” ì›€ì§ì´ê¸° ì‹œì‘
                    }
                });
            }
            // ğŸ“Œ íŒ” ì›€ì§ì´ëŠ” ì• ë‹ˆë©”ì´ì…˜
            function animateWorkerArms() {
                if (!worker) {
                    console.error("Worker ëª¨ë¸ì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
                    return;
                }
                worker.traverse(function (child) {
                    console.log(`ğŸ¯ íƒ€ì…: ${child.type}, ì´ë¦„: ${child.name ? child.name : "ì´ë¦„ ì—†ìŒ"}`);
                    if (child.isMesh && child.name.includes("Arm")) {  // íŒ” ì¡°ì¸íŠ¸ ì°¾ê¸° (ëª¨ë¸ì— ë”°ë¼ ìˆ˜ì • í•„ìš”)
                        gsap.to(child.rotation, {
                            x: Math.PI / 8, // íŒ”ì„ ì‚´ì§ ë“¤ì–´ ì˜¬ë¦¬ê¸°
                            repeat: -1, // ë¬´í•œ ë°˜ë³µ
                            yoyo: true, // ì•ë’¤ë¡œ ì›€ì§ì„ ë°˜ë³µ
                            duration: 0.5 // ì†ë„
                        });
                    }
                });
            }
            }

            function addFog() {
            scene.fog = new THREE.Fog(0x555555, 200, 300); // íë¦° ê³µê¸°, ë¨¼ì§€ ëŠë‚Œ
        }   

        function createSkyDome() {
            const skyGeometry = new THREE.SphereGeometry(600, 32, 32); // âœ… ìŠ¤ì¹´ì´ë” í¬ê¸° & ì„¸ê·¸ë¨¼íŠ¸
            const textureLoader = new THREE.TextureLoader();
            
            // âœ… ì—…ë¡œë“œí•œ sky.jpg íŒŒì¼ì„ ì‚¬ìš©
            const skyTexture = textureLoader.load("/models/industrial/textures/sky.jpg", function(texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1); // âœ… í…ìŠ¤ì²˜ ë°˜ë³µ ì¡°ì •
            });

            // âœ… ìŠ¤ì¹´ì´ë” ë¨¸í‹°ë¦¬ì–¼ ìƒì„±
            const skyMaterial = new THREE.MeshBasicMaterial({
                map: skyTexture,
                side: THREE.BackSide // âœ… ë‚´ë¶€ì—ì„œ ë³´ì´ë„ë¡ ì„¤ì •
            });

            // âœ… ìŠ¤ì¹´ì´ë” ë©”ì‰¬ ìƒì„±
            const skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(skyDome);

            // âœ… êµ¬ë¦„ ì›€ì§ì„ ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
            function animateSky() {
                requestAnimationFrame(animateSky);
                if (skyTexture) {
                    skyTexture.offset.x += 0.0001; // ìˆ˜í‰ ì´ë™
                    skyTexture.offset.y += 0.00005; // ìˆ˜ì§ ì´ë™
                }
            }
            animateSky(); // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
        }

        function createGround() {
            const textureLoader = new THREE.TextureLoader();
            
            // âœ… ì—…ë¡œë“œí•œ ë°”ë‹¥ í…ìŠ¤ì²˜ ì‚¬ìš©
            const groundTexture = textureLoader.load("/models/industrial/textures/concrete.jpg", function(texture) {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(10, 10); // âœ… í…ìŠ¤ì²˜ ë°˜ë³µ ì ìš© (íƒ€ì¼ë§)
            });

            // âœ… ë°”ë‹¥ ë¨¸í‹°ë¦¬ì–¼ ì„¤ì •
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture, // âœ… í…ìŠ¤ì²˜ ì ìš©
                roughness: 0.8, // ê±°ì¹ ê¸°
                metalness: 0.1, // ê¸ˆì†ì„±
            });

            // âœ… ë°”ë‹¥ í‰ë©´ ìƒì„±
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // âœ… ìˆ˜í‰ ë°”ë‹¥ìœ¼ë¡œ íšŒì „
            ground.position.y = -1.5; // âœ… ì‚´ì§ ì•„ë˜ë¡œ ë°°ì¹˜
            scene.add(ground);
        }

        function updateZoom() {
            camera.fov = settings.zoom;
            camera.updateProjectionMatrix();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (settings.enableAuto) {
                const time = Date.now() * 0.001;
                camera.position.x = Math.sin(time * settings.speed) * settings.radius;
                camera.position.z = Math.cos(time * settings.speed) * settings.radius;
                camera.position.y = settings.height;
                camera.lookAt(0, 10, 0);
            }
// 1
            controls.update();
            renderer.render(scene, camera);
        }
        function animateCameraMove() {
            let startX = camera.position.x; // ì´ˆê¸° X ìœ„ì¹˜
            let moveRight1 = 45; // ì²« ë²ˆì§¸ ì˜¤ë¥¸ìª½ ì´ë™ ê±°ë¦¬
            let moveLeft = 30;   // ì™¼ìª½ ì´ë™ ê±°ë¦¬
            let moveRight2 = 20; // ë‘ ë²ˆì§¸ ì˜¤ë¥¸ìª½ ì´ë™ ê±°ë¦¬
            let zoomIn = 5;     // ì¤Œ ì¸ ê°’ (FOV ì¶•ì†Œ)
            let zoomOut = 10;    // ì¤Œ ì•„ì›ƒ ê°’ (FOV í™•ëŒ€)
            let duration = 5;    // ê° ì´ë™ ì‹œê°„ (ì´ˆ)

            let timeline = gsap.timeline({ repeat: -1, yoyo: false }); // ê³„ì† ë°˜ë³µ

            timeline
                .to(camera.position, { 
                    x: startX + moveRight1, 
                  
                    duration: duration, 
                    ease: "power1.inOut",
                    onUpdate: () => camera.lookAt(worker.position) // ìˆ˜ë¦¬ì›ì„ ê³„ì† ë°”ë¼ë³´ê²Œ ì„¤ì •
                })
                .to(camera, { 
                    fov: zoomIn, 
                    duration: duration / 0.5, // ì¤Œ ë³€ê²½ ì†ë„
                    ease: "power1.inOut",
                    onUpdate: () => camera.updateProjectionMatrix() 
                })
                .to(camera.position, { 
                    x: startX + moveRight1 - moveLeft, 
                    duration: duration, 
                    ease: "power1.inOut",
                    onUpdate: () => camera.lookAt(worker.position) 
                })
                .to(camera, { 
                    fov: zoomOut, 
                    duration: duration / 1, 
                    ease: "power1.inOut",
                    onUpdate: () => camera.updateProjectionMatrix() 
                })
                .to(camera.position, { 
                    x: startX + moveRight1 - moveLeft + moveRight2, 
                    duration: duration, 
                    ease: "power1.inOut",
                    onUpdate: () => camera.lookAt(worker.position) 
                });
        }

        // âœ… ì¹´ë©”ë¼ ì´ë™ ì‹¤í–‰
        window.onload = function() {
            init();
            setTimeout(animateCameraMove, 2000); // 2ì´ˆ í›„ ì‹¤í–‰
        };
    </script>
</body>
</html>